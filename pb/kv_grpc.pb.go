// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pbraft

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KvStoreClient is the client API for KvStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KvStoreClient interface {
	Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Result, error)
	Set(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*Result, error)
	Clear(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Result, error)
	CAS(ctx context.Context, in *CASArg, opts ...grpc.CallOption) (*Result, error)
	PeerJoin(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error)
	PeerLeave(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error)
}

type kvStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewKvStoreClient(cc grpc.ClientConnInterface) KvStoreClient {
	return &kvStoreClient{cc}
}

func (c *kvStoreClient) Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.KvStore/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kvStoreClient) Set(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.KvStore/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kvStoreClient) Clear(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.KvStore/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kvStoreClient) CAS(ctx context.Context, in *CASArg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.KvStore/CAS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kvStoreClient) PeerJoin(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.KvStore/PeerJoin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kvStoreClient) PeerLeave(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.KvStore/PeerLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KvStoreServer is the server API for KvStore service.
// All implementations should embed UnimplementedKvStoreServer
// for forward compatibility
type KvStoreServer interface {
	Get(context.Context, *Key) (*Result, error)
	Set(context.Context, *KeyValue) (*Result, error)
	Clear(context.Context, *Empty) (*Result, error)
	CAS(context.Context, *CASArg) (*Result, error)
	PeerJoin(context.Context, *Peer) (*Result, error)
	PeerLeave(context.Context, *Peer) (*Result, error)
}

// UnimplementedKvStoreServer should be embedded to have forward compatible implementations.
type UnimplementedKvStoreServer struct {
}

func (UnimplementedKvStoreServer) Get(context.Context, *Key) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedKvStoreServer) Set(context.Context, *KeyValue) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedKvStoreServer) Clear(context.Context, *Empty) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedKvStoreServer) CAS(context.Context, *CASArg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CAS not implemented")
}
func (UnimplementedKvStoreServer) PeerJoin(context.Context, *Peer) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerJoin not implemented")
}
func (UnimplementedKvStoreServer) PeerLeave(context.Context, *Peer) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerLeave not implemented")
}

// UnsafeKvStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KvStoreServer will
// result in compilation errors.
type UnsafeKvStoreServer interface {
	mustEmbedUnimplementedKvStoreServer()
}

func RegisterKvStoreServer(s grpc.ServiceRegistrar, srv KvStoreServer) {
	s.RegisterService(&KvStore_ServiceDesc, srv)
}

func _KvStore_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KvStoreServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.KvStore/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KvStoreServer).Get(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _KvStore_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KvStoreServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.KvStore/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KvStoreServer).Set(ctx, req.(*KeyValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KvStore_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KvStoreServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.KvStore/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KvStoreServer).Clear(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _KvStore_CAS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CASArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KvStoreServer).CAS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.KvStore/CAS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KvStoreServer).CAS(ctx, req.(*CASArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _KvStore_PeerJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Peer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KvStoreServer).PeerJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.KvStore/PeerJoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KvStoreServer).PeerJoin(ctx, req.(*Peer))
	}
	return interceptor(ctx, in, info, handler)
}

func _KvStore_PeerLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Peer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KvStoreServer).PeerLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.KvStore/PeerLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KvStoreServer).PeerLeave(ctx, req.(*Peer))
	}
	return interceptor(ctx, in, info, handler)
}

// KvStore_ServiceDesc is the grpc.ServiceDesc for KvStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KvStore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.KvStore",
	HandlerType: (*KvStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _KvStore_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _KvStore_Set_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _KvStore_Clear_Handler,
		},
		{
			MethodName: "CAS",
			Handler:    _KvStore_CAS_Handler,
		},
		{
			MethodName: "PeerJoin",
			Handler:    _KvStore_PeerJoin_Handler,
		},
		{
			MethodName: "PeerLeave",
			Handler:    _KvStore_PeerLeave_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv.proto",
}

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RaftClient interface {
	AppendEntries(ctx context.Context, in *AppendEntriesArgs, opts ...grpc.CallOption) (*AppendEntriesRet, error)
	RequestVote(ctx context.Context, in *RequestVoteArgs, opts ...grpc.CallOption) (*RequestVoteRet, error)
	InstallSnapshot(ctx context.Context, in *InstallSnapshotArgs, opts ...grpc.CallOption) (*InstallSnapshotRet, error)
}

type raftClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftClient(cc grpc.ClientConnInterface) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) AppendEntries(ctx context.Context, in *AppendEntriesArgs, opts ...grpc.CallOption) (*AppendEntriesRet, error) {
	out := new(AppendEntriesRet)
	err := c.cc.Invoke(ctx, "/pb.Raft/AppendEntries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) RequestVote(ctx context.Context, in *RequestVoteArgs, opts ...grpc.CallOption) (*RequestVoteRet, error) {
	out := new(RequestVoteRet)
	err := c.cc.Invoke(ctx, "/pb.Raft/RequestVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) InstallSnapshot(ctx context.Context, in *InstallSnapshotArgs, opts ...grpc.CallOption) (*InstallSnapshotRet, error) {
	out := new(InstallSnapshotRet)
	err := c.cc.Invoke(ctx, "/pb.Raft/InstallSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
// All implementations should embed UnimplementedRaftServer
// for forward compatibility
type RaftServer interface {
	AppendEntries(context.Context, *AppendEntriesArgs) (*AppendEntriesRet, error)
	RequestVote(context.Context, *RequestVoteArgs) (*RequestVoteRet, error)
	InstallSnapshot(context.Context, *InstallSnapshotArgs) (*InstallSnapshotRet, error)
}

// UnimplementedRaftServer should be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (UnimplementedRaftServer) AppendEntries(context.Context, *AppendEntriesArgs) (*AppendEntriesRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendEntries not implemented")
}
func (UnimplementedRaftServer) RequestVote(context.Context, *RequestVoteArgs) (*RequestVoteRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}
func (UnimplementedRaftServer) InstallSnapshot(context.Context, *InstallSnapshotArgs) (*InstallSnapshotRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallSnapshot not implemented")
}

// UnsafeRaftServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaftServer will
// result in compilation errors.
type UnsafeRaftServer interface {
	mustEmbedUnimplementedRaftServer()
}

func RegisterRaftServer(s grpc.ServiceRegistrar, srv RaftServer) {
	s.RegisterService(&Raft_ServiceDesc, srv)
}

func _Raft_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntriesArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).AppendEntries(ctx, req.(*AppendEntriesArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).RequestVote(ctx, req.(*RequestVoteArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_InstallSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallSnapshotArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).InstallSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/InstallSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).InstallSnapshot(ctx, req.(*InstallSnapshotArgs))
	}
	return interceptor(ctx, in, info, handler)
}

// Raft_ServiceDesc is the grpc.ServiceDesc for Raft service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Raft_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendEntries",
			Handler:    _Raft_AppendEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _Raft_RequestVote_Handler,
		},
		{
			MethodName: "InstallSnapshot",
			Handler:    _Raft_InstallSnapshot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv.proto",
}

// ShardMasterClient is the client API for ShardMaster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShardMasterClient interface {
	GetKeyGroup(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Result, error)
	Reconfig(ctx context.Context, in *ReconfigArgs, opts ...grpc.CallOption) (*Result, error)
	GetReconfig(ctx context.Context, in *ConfigId, opts ...grpc.CallOption) (*Result, error)
}

type shardMasterClient struct {
	cc grpc.ClientConnInterface
}

func NewShardMasterClient(cc grpc.ClientConnInterface) ShardMasterClient {
	return &shardMasterClient{cc}
}

func (c *shardMasterClient) GetKeyGroup(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardMaster/GetKeyGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardMasterClient) Reconfig(ctx context.Context, in *ReconfigArgs, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardMaster/Reconfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardMasterClient) GetReconfig(ctx context.Context, in *ConfigId, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardMaster/GetReconfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShardMasterServer is the server API for ShardMaster service.
// All implementations should embed UnimplementedShardMasterServer
// for forward compatibility
type ShardMasterServer interface {
	GetKeyGroup(context.Context, *Key) (*Result, error)
	Reconfig(context.Context, *ReconfigArgs) (*Result, error)
	GetReconfig(context.Context, *ConfigId) (*Result, error)
}

// UnimplementedShardMasterServer should be embedded to have forward compatible implementations.
type UnimplementedShardMasterServer struct {
}

func (UnimplementedShardMasterServer) GetKeyGroup(context.Context, *Key) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyGroup not implemented")
}
func (UnimplementedShardMasterServer) Reconfig(context.Context, *ReconfigArgs) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reconfig not implemented")
}
func (UnimplementedShardMasterServer) GetReconfig(context.Context, *ConfigId) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReconfig not implemented")
}

// UnsafeShardMasterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShardMasterServer will
// result in compilation errors.
type UnsafeShardMasterServer interface {
	mustEmbedUnimplementedShardMasterServer()
}

func RegisterShardMasterServer(s grpc.ServiceRegistrar, srv ShardMasterServer) {
	s.RegisterService(&ShardMaster_ServiceDesc, srv)
}

func _ShardMaster_GetKeyGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardMasterServer).GetKeyGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardMaster/GetKeyGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardMasterServer).GetKeyGroup(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardMaster_Reconfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconfigArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardMasterServer).Reconfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardMaster/Reconfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardMasterServer).Reconfig(ctx, req.(*ReconfigArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardMaster_GetReconfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardMasterServer).GetReconfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardMaster/GetReconfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardMasterServer).GetReconfig(ctx, req.(*ConfigId))
	}
	return interceptor(ctx, in, info, handler)
}

// ShardMaster_ServiceDesc is the grpc.ServiceDesc for ShardMaster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShardMaster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ShardMaster",
	HandlerType: (*ShardMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKeyGroup",
			Handler:    _ShardMaster_GetKeyGroup_Handler,
		},
		{
			MethodName: "Reconfig",
			Handler:    _ShardMaster_Reconfig_Handler,
		},
		{
			MethodName: "GetReconfig",
			Handler:    _ShardMaster_GetReconfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv.proto",
}

// ShardKvClient is the client API for ShardKv service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShardKvClient interface {
	Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Result, error)
	Set(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*Result, error)
	Clear(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Result, error)
	CAS(ctx context.Context, in *CASArg, opts ...grpc.CallOption) (*Result, error)
	PeerJoin(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error)
	PeerLeave(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error)
	KeyMigration(ctx context.Context, in *Reconfig, opts ...grpc.CallOption) (*Result, error)
}

type shardKvClient struct {
	cc grpc.ClientConnInterface
}

func NewShardKvClient(cc grpc.ClientConnInterface) ShardKvClient {
	return &shardKvClient{cc}
}

func (c *shardKvClient) Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardKvClient) Set(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardKvClient) Clear(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardKvClient) CAS(ctx context.Context, in *CASArg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/CAS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardKvClient) PeerJoin(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/PeerJoin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardKvClient) PeerLeave(ctx context.Context, in *Peer, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/PeerLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardKvClient) KeyMigration(ctx context.Context, in *Reconfig, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.ShardKv/KeyMigration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShardKvServer is the server API for ShardKv service.
// All implementations should embed UnimplementedShardKvServer
// for forward compatibility
type ShardKvServer interface {
	Get(context.Context, *Key) (*Result, error)
	Set(context.Context, *KeyValue) (*Result, error)
	Clear(context.Context, *Empty) (*Result, error)
	CAS(context.Context, *CASArg) (*Result, error)
	PeerJoin(context.Context, *Peer) (*Result, error)
	PeerLeave(context.Context, *Peer) (*Result, error)
	KeyMigration(context.Context, *Reconfig) (*Result, error)
}

// UnimplementedShardKvServer should be embedded to have forward compatible implementations.
type UnimplementedShardKvServer struct {
}

func (UnimplementedShardKvServer) Get(context.Context, *Key) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedShardKvServer) Set(context.Context, *KeyValue) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedShardKvServer) Clear(context.Context, *Empty) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedShardKvServer) CAS(context.Context, *CASArg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CAS not implemented")
}
func (UnimplementedShardKvServer) PeerJoin(context.Context, *Peer) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerJoin not implemented")
}
func (UnimplementedShardKvServer) PeerLeave(context.Context, *Peer) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerLeave not implemented")
}
func (UnimplementedShardKvServer) KeyMigration(context.Context, *Reconfig) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyMigration not implemented")
}

// UnsafeShardKvServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShardKvServer will
// result in compilation errors.
type UnsafeShardKvServer interface {
	mustEmbedUnimplementedShardKvServer()
}

func RegisterShardKvServer(s grpc.ServiceRegistrar, srv ShardKvServer) {
	s.RegisterService(&ShardKv_ServiceDesc, srv)
}

func _ShardKv_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).Get(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardKv_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).Set(ctx, req.(*KeyValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardKv_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).Clear(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardKv_CAS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CASArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).CAS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/CAS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).CAS(ctx, req.(*CASArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardKv_PeerJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Peer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).PeerJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/PeerJoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).PeerJoin(ctx, req.(*Peer))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardKv_PeerLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Peer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).PeerLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/PeerLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).PeerLeave(ctx, req.(*Peer))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardKv_KeyMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reconfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardKvServer).KeyMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ShardKv/KeyMigration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardKvServer).KeyMigration(ctx, req.(*Reconfig))
	}
	return interceptor(ctx, in, info, handler)
}

// ShardKv_ServiceDesc is the grpc.ServiceDesc for ShardKv service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShardKv_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ShardKv",
	HandlerType: (*ShardKvServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ShardKv_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _ShardKv_Set_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _ShardKv_Clear_Handler,
		},
		{
			MethodName: "CAS",
			Handler:    _ShardKv_CAS_Handler,
		},
		{
			MethodName: "PeerJoin",
			Handler:    _ShardKv_PeerJoin_Handler,
		},
		{
			MethodName: "PeerLeave",
			Handler:    _ShardKv_PeerLeave_Handler,
		},
		{
			MethodName: "KeyMigration",
			Handler:    _ShardKv_KeyMigration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kv.proto",
}
